//
// Copyright 2013 (C). Alex Robenko. All rights reserved.
//

// This file is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.


#include <cstdint>
#include <algorithm>
#include <limits>
#include <memory>
#include <iterator>
#include <type_traits>

#include "comms/comms.h"
#include "cxxtest/TestSuite.h"


class FieldsTestSuite : public CxxTest::TestSuite
{
public:
    void test1();
    void test2();
    void test3();
    void test4();
    void test5();
    void test6();
    void test7();
    void test8();
    void test9();
    void test10();
    void test11();
    void test12();
    void test13();
    void test14();
    void test15();
    void test16();
    void test17();
    void test18();
    void test19();

private:
    typedef comms::option::UseBigEndian UseBigEndianOpt;
    typedef comms::option::UseLittleEndian UseLittleEndianOpt;

    enum Enum1 {
        Enum1_Value1,
        Enum1_Value2,
        Enum1_Value3,
        Enum1_NumOfValues
    };

    enum class Enum2 {
        Value1,
        Value2,
        Value3,
        Value4,
        NumOfValues
    };


    template <typename TField>
    static TField readWriteField(
        const char* buf,
        std::size_t size,
        comms::ErrorStatus expectedStatus = comms::ErrorStatus::Success);

    template <typename TField>
    void writeReadField(
        const TField& field,
        const char* expectedBuf,
        std::size_t size,
        comms::ErrorStatus expectedStatus = comms::ErrorStatus::Success);
};

namespace cfo = comms::field::option;

void FieldsTestSuite::test1()
{
    typedef comms::field::BasicIntValue<
        comms::Field<UseBigEndianOpt>,
        std::uint32_t> Field;

    static const char Buf[] = {
        0x01, 0x02, 0x03, 0x04
    };

    static const std::size_t BufSize = std::extent<decltype(Buf)>::value;
    auto field = readWriteField<Field>(Buf, BufSize);
    static_assert(field.length() == sizeof(std::uint32_t), "Sizes do not match");

    TS_ASSERT_EQUALS(field.getValue(), 0x01020304);
    TS_ASSERT(field.valid());
}

void FieldsTestSuite::test2()
{
    typedef comms::field::BasicIntValue<
        comms::Field<UseBigEndianOpt>,
        std::uint32_t,
        cfo::LengthLimitImpl<3>
    > Field;

    static const char Buf[] = {
        0x01, 0x02, 0x03, 0x04
    };

    static const std::size_t BufSize = std::extent<decltype(Buf)>::value;
    auto field = readWriteField<Field>(Buf, BufSize);
    static_assert(field.length() == 3, "Sizes do not match");

    TS_ASSERT_EQUALS(field.getValue(), 0x010203);
    TS_ASSERT(field.valid());
}

void FieldsTestSuite::test3()
{
    typedef comms::field::BasicIntValue<
        comms::Field<UseBigEndianOpt>,
        std::int16_t
    > Field;

    static const char Buf[] = {
        0x01, 0x02
    };
    static const std::size_t BufSize = std::extent<decltype(Buf)>::value;
    auto field = readWriteField<Field>(Buf, BufSize);
    static_assert(field.length() == sizeof(std::int16_t), "Sizes do not match");

    TS_ASSERT_EQUALS(field.getValue(), static_cast<std::int16_t>(0x0102));
    TS_ASSERT(field.valid());
}

void FieldsTestSuite::test4()
{
    typedef comms::field::BasicIntValue<
        comms::Field<UseBigEndianOpt>,
        std::int16_t
    > Field;

    static const char Buf[] = {
        (char)0xff, (char)0xff
    };
    static const std::size_t BufSize = std::extent<decltype(Buf)>::value;
    auto field = readWriteField<Field>(Buf, BufSize);
    static_assert(field.length() == sizeof(std::int16_t), "Sizes do not match");

    TS_ASSERT_EQUALS(field.getValue(), -1);
    TS_ASSERT(field.valid());
}

void FieldsTestSuite::test5()
{
    typedef comms::field::BasicIntValue<
        comms::Field<UseLittleEndianOpt>,
        std::int16_t
    > Field;

    static const char Buf[] = {
        0x0, (char)0x80
    };
    static const std::size_t BufSize = std::extent<decltype(Buf)>::value;
    auto field = readWriteField<Field>(Buf, BufSize);
    static_assert(field.length() == sizeof(std::int16_t), "Sizes do not match");

    TS_ASSERT_EQUALS(field.getValue(), std::numeric_limits<std::int16_t>::min());
    TS_ASSERT(field.valid());
}

void FieldsTestSuite::test6()
{
    typedef comms::field::BasicIntValue<
        comms::Field<UseBigEndianOpt>,
        std::int16_t,
        cfo::LengthLimitImpl<1>
    > Field;

    static const char Buf[] = {
        (char)0xff, 0x00
    };
    static const std::size_t BufSize = std::extent<decltype(Buf)>::value;
    auto field = readWriteField<Field>(Buf, BufSize);
    static_assert(field.length() == 1, "Sizes do not match");

    TS_ASSERT_EQUALS(field.getValue(), -1);
    TS_ASSERT(field.valid());
}

void FieldsTestSuite::test7()
{
    typedef comms::field::BasicIntValue<
        comms::Field<UseBigEndianOpt>,
        std::int16_t,
        cfo::LengthLimitImpl<1>,
        cfo::SerOffsetImpl<-2000>
    > Field;

    static const char Buf[] = {
        13
    };
    static const std::size_t BufSize = std::extent<decltype(Buf)>::value;
    auto field = readWriteField<Field>(Buf, BufSize);

    static_assert(field.length() == 1, "Sizes do not match");

    TS_ASSERT_EQUALS(field.getValue(), 2013);
    TS_ASSERT_EQUALS(field.getSerialisedValue(), 13);
    TS_ASSERT(field.valid());
}

void FieldsTestSuite::test8()
{
    typedef comms::field::BasicIntValue<
        comms::Field<UseBigEndianOpt>,
        std::uint32_t,
        cfo::LengthLimitImpl<3>,
        cfo::ValidRangeImpl<0, 0x010200>
    > Field;

    static const char Buf[] = {
        0x01, 0x02, 0x03, 0x04
    };

    static const std::size_t BufSize = std::extent<decltype(Buf)>::value;
    auto field = readWriteField<Field>(Buf, BufSize);
    static_assert(field.length() == 3, "Sizes do not match");

    TS_ASSERT_EQUALS(field.getValue(), 0x010203);
    TS_ASSERT(!field.valid());
}

void FieldsTestSuite::test9()
{
    typedef comms::field::BasicIntValue<
        comms::Field<UseBigEndianOpt>,
        std::uint8_t,
        cfo::ValidRangeImpl<0, 10>,
        cfo::DefaultValueImpl<100>
    > Field;

    Field field;
    TS_ASSERT_EQUALS(field.getValue(), 100);
    TS_ASSERT(!field.valid());

    static const char Buf[] = {
        0x05, 0x02
    };

    static const std::size_t BufSize = std::extent<decltype(Buf)>::value;
    field = readWriteField<Field>(Buf, BufSize);
    static_assert(field.length() == 1, "Sizes do not match");

    TS_ASSERT_EQUALS(field.getValue(), 0x05);
    TS_ASSERT(field.valid());
}

void FieldsTestSuite::test10()
{
    typedef comms::field::BitmaskValue<
        comms::Field<UseBigEndianOpt>,
        comms::field::option::LengthLimitImpl<2>
    > Field;

    Field field;
    TS_ASSERT(field.valid());
    TS_ASSERT_EQUALS(field.getValue(), 0U);

    static const char Buf[] = {
        (char)0xde, (char)0xad,
    };
    static const std::size_t BufSize = std::extent<decltype(Buf)>::value;
    field = readWriteField<Field>(Buf, BufSize);
    static_assert(field.length() == 2, "Sizes do not match");

    TS_ASSERT_EQUALS(field.getValue(), 0xdead);
    TS_ASSERT_EQUALS(field.getSerialisedValue(), field.getValue());

    field.setBits(0x2);
    TS_ASSERT_EQUALS(field.getValue(), 0xdeaf);
    TS_ASSERT(field.valid());

    static const char ExpectedBuf[] = {
        (char)0xde, (char)0xaf
    };
    const std::size_t ExpectedBufSize = std::extent<decltype(ExpectedBuf)>::value;
    writeReadField(field, ExpectedBuf, ExpectedBufSize);
}

void FieldsTestSuite::test11()
{
    typedef comms::field::BitmaskValue<
        comms::Field<UseLittleEndianOpt>,
        comms::field::option::LengthLimitImpl<3>,
        cfo::DefaultValueImpl<0xffffff>,
        cfo::BitmaskReservedBitsImpl<0xff0000, 0>
    > Field;

    Field field;
    TS_ASSERT(!field.valid());
    TS_ASSERT_EQUALS(field.getValue(), 0xffffff);

    static const char Buf[] = {
        (char)0xde, (char)0xad, (char)0x00, (char)0xff
    };
    static const std::size_t BufSize = std::extent<decltype(Buf)>::value;
    field = readWriteField<Field>(Buf, BufSize);
    static_assert(field.length() == 3, "Sizes do not match");

    TS_ASSERT_EQUALS(field.getValue(), 0xadde);
    TS_ASSERT_EQUALS(field.getSerialisedValue(), field.getValue());
    TS_ASSERT(field.valid());

    field.setBits(0x10000);
    TS_ASSERT_EQUALS(field.getValue(), 0x1adde);
    TS_ASSERT(!field.valid());
}

void FieldsTestSuite::test12()
{
    typedef comms::field::BasicEnumValue<
        comms::Field<UseBigEndianOpt>,
        Enum1,
        cfo::LengthLimitImpl<1>,
        cfo::ValidRangeImpl<0, Enum1_NumOfValues - 1>,
        cfo::DefaultValueImpl<Enum1_NumOfValues>
    > Field;

    Field field;
    TS_ASSERT(!field.valid());
    TS_ASSERT_EQUALS(field.getValue(), Enum1_NumOfValues);

    static const char Buf[] = {
        (char)Enum1_Value1, (char)0x3f
    };
    static const std::size_t BufSize = std::extent<decltype(Buf)>::value;
    field = readWriteField<Field>(Buf, BufSize);
    static_assert(field.length() == 1, "Sizes do not match");

    TS_ASSERT_EQUALS(field.getValue(), Enum1_Value1);
    TS_ASSERT_EQUALS(field.getSerialisedValue(), field.asIntValueField().getValue());
    TS_ASSERT(field.valid());

    field.setValue(Enum1_NumOfValues);
    TS_ASSERT(!field.valid());
    field.setValue(Enum1_Value2);

    static const char ExpectedBuf[] = {
        (char)Enum1_Value2
    };
    static const std::size_t ExpectedBufSize = std::extent<decltype(ExpectedBuf)>::value;
    writeReadField(field, ExpectedBuf, ExpectedBufSize);
}

void FieldsTestSuite::test13()
{
    typedef comms::field::BasicEnumValue<
        comms::Field<UseBigEndianOpt>,
        Enum2,
        cfo::LengthLimitImpl<2>,
        cfo::ValidRangeImpl<0, (int)(Enum2::NumOfValues) - 1>,
        cfo::DefaultValueImpl<(int)Enum2::NumOfValues>
    > Field;

    Field field;
    TS_ASSERT(!field.valid());
    TS_ASSERT_EQUALS(field.getValue(), Enum2::NumOfValues);

    static const char Buf[] = {
        0x0, (char)Enum2::Value4, (char)0x3f
    };
    static const std::size_t BufSize = std::extent<decltype(Buf)>::value;
    field = readWriteField<Field>(Buf, BufSize);
    static_assert(field.length() == 2, "Sizes do not match");

    TS_ASSERT_EQUALS(field.getValue(), Enum2::Value4);
    TS_ASSERT_EQUALS(field.getSerialisedValue(), field.asIntValueField().getValue());
    TS_ASSERT(field.valid());

    field.setValue(Enum2::NumOfValues);
    TS_ASSERT(!field.valid());
    field.setValue(Enum2::Value3);

    static const char ExpectedBuf[] = {
        0x0, (char)Enum2::Value3
    };
    static const std::size_t ExpectedBufSize = std::extent<decltype(ExpectedBuf)>::value;
    writeReadField(field, ExpectedBuf, ExpectedBufSize);
}

void FieldsTestSuite::test14()
{
    typedef comms::field::VarSizeArray<
        comms::Field<UseBigEndianOpt>,
        comms::field::BasicIntValue<
            comms::Field<UseBigEndianOpt>,
            std::uint8_t
        >
    > Field;

    Field field;
    TS_ASSERT(field.valid());

    static const char Buf[] = {
        0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9
    };
    static const std::size_t BufSize = std::extent<decltype(Buf)>::value;
    field = readWriteField<Field>(Buf, BufSize);
    TS_ASSERT_EQUALS(field.length(), BufSize);
    TS_ASSERT(field.valid());
}

void FieldsTestSuite::test15()
{
    typedef comms::field::VarSizeArray<
        comms::Field<UseBigEndianOpt>,
        comms::field::BasicIntValue<
            comms::Field<UseBigEndianOpt>,
            std::uint8_t
        >,
        comms::field::option::FixedSizeStorage<32>
    > Field;

    Field field;
    TS_ASSERT(field.valid());

    static const char Buf[] = {
        0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9
    };
    static const std::size_t BufSize = std::extent<decltype(Buf)>::value;
    field = readWriteField<Field>(Buf, BufSize);
    TS_ASSERT_EQUALS(field.length(), BufSize);
    TS_ASSERT(field.valid());

    static const char Buf2[] = {
        0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc
    };
    static const std::size_t BufSize2 = std::extent<decltype(Buf)>::value;
    field = readWriteField<Field>(Buf2, BufSize2);
    TS_ASSERT_EQUALS(field.length(), BufSize2);
    TS_ASSERT(field.valid());
}

void FieldsTestSuite::test16()
{
    typedef comms::field::StaticString<
        comms::Field<UseBigEndianOpt>
    > Field;

    Field field;
    TS_ASSERT(field.valid());
    TS_ASSERT(field.empty());

    static const char ExpectedBuf[] = {
        0x0
    };
    static const std::size_t ExpectedBufSize = std::extent<decltype(ExpectedBuf)>::value;
    writeReadField(field, ExpectedBuf, ExpectedBufSize);

    static const char Buf[] = {
        0x5, 'h', 'e', 'l', 'l', 'o', 'g', 'a', 'r'
    };
    static const std::size_t BufSize = std::extent<decltype(Buf)>::value;
    field = readWriteField<Field>(Buf, BufSize);
    TS_ASSERT_EQUALS(field.size(), static_cast<std::size_t>(Buf[0]));
    TS_ASSERT_EQUALS(field.length(), field.size() + 1U);
    TS_ASSERT(field.valid());
}

void FieldsTestSuite::test17()
{
    typedef comms::field::StaticString<
        comms::Field<UseBigEndianOpt>,
        comms::field::option::SetValidStringMaxSize<4>
    > Field;

    Field field;
    TS_ASSERT(field.valid());
    TS_ASSERT(field.empty());

    static const char Buf[] = {
        0x5, 'h', 'e', 'l', 'l', 'o', 'g', 'a', 'r'
    };
    static const std::size_t BufSize = std::extent<decltype(Buf)>::value;
    field = readWriteField<Field>(Buf, BufSize);
    TS_ASSERT_EQUALS(field.size(), static_cast<std::size_t>(Buf[0]));
    TS_ASSERT_EQUALS(field.length(), field.size() + 1U);
    TS_ASSERT(!field.valid());
    TS_ASSERT_EQUALS(field.getValue(), std::string("hello"));
}

void FieldsTestSuite::test18()
{
    struct HelloInitialiser
    {
        static const char* begin()
        {
            static const std::string Str("hello");
            return Str.c_str();
        }

        static std::size_t size()
        {
            return sizeof("hello") - 1;
        }
    };

    typedef comms::field::StaticString<
        comms::Field<UseBigEndianOpt>,
        comms::field::option::SetDefaultValueInitialiser<HelloInitialiser>,
        comms::field::option::SetStringSizeLengthLimit<2>
    > Field;

    Field field;
    TS_ASSERT(field.valid());
    TS_ASSERT(!field.empty());
    TS_ASSERT_EQUALS(field.getValue(), std::string("hello"));
    field.clear();
    TS_ASSERT(field.empty());
    field.setValue("bla");
    TS_ASSERT_EQUALS(field.getValue(), std::string("bla"));
    TS_ASSERT_EQUALS(field.size(), 3);
    TS_ASSERT_EQUALS(field.length(), 5);

    static const char ExpectedBuf[] = {
        0x0, 0x3, 'b', 'l', 'a'
    };
    static const std::size_t ExpectedBufSize = std::extent<decltype(ExpectedBuf)>::value;
    writeReadField(field, ExpectedBuf, ExpectedBufSize);
}

void FieldsTestSuite::test19()
{
    typedef comms::field::StaticString<
        comms::Field<UseBigEndianOpt>
    > Field;

    Field field;
    TS_ASSERT(field.valid());
    TS_ASSERT(field.empty());

    static const std::string Str("hello");
    std::copy(Str.begin(), Str.end(), std::back_inserter(field));
    TS_ASSERT(!field.empty());
    TS_ASSERT_EQUALS(field.size(), Str.size());
    TS_ASSERT_EQUALS(field.getValue(), Str);

    static const char ExpectedBuf[] = {
        0x5, 'h', 'e', 'l', 'l', 'o'
    };
    static const std::size_t ExpectedBufSize = std::extent<decltype(ExpectedBuf)>::value;
    writeReadField(field, ExpectedBuf, ExpectedBufSize);
}

template <typename TField>
TField FieldsTestSuite::readWriteField(
    const char* buf,
    std::size_t size,
    comms::ErrorStatus expectedStatus)
{
    typedef TField Field;
    Field field;

    auto iter = buf;
    auto status = field.read(iter, size);
    TS_ASSERT_EQUALS(status, expectedStatus);

    if (status != comms::ErrorStatus::Success) {
        return field;
    }

    auto diff = static_cast<std::size_t>(std::distance(buf, iter));
    TS_ASSERT_EQUALS(field.length(), diff);

    std::unique_ptr<char[]> outDataBuf(new char[diff]);
    auto writeIter = &outDataBuf[0];

    status = field.write(writeIter, diff);
    TS_ASSERT_EQUALS(status, comms::ErrorStatus::Success);
    TS_ASSERT(std::equal(buf, buf + diff, &outDataBuf[0]));

    auto writeDiff = static_cast<std::size_t>(std::distance(&outDataBuf[0], writeIter));
    TS_ASSERT_EQUALS(field.length(), writeDiff);
    TS_ASSERT_EQUALS(diff, writeDiff);
    return field;
}

template <typename TField>
void FieldsTestSuite::writeReadField(
    const TField& field,
    const char* expectedBuf,
    std::size_t size,
    comms::ErrorStatus expectedStatus)
{
    std::unique_ptr<char[]> outDataBuf(new char[size]);
    auto writeIter = &outDataBuf[0];
    auto es = field.write(writeIter, size);
    TS_ASSERT_EQUALS(es, expectedStatus);
    TS_ASSERT(std::equal(expectedBuf, expectedBuf + size, &outDataBuf[0]));

    if (es == comms::ErrorStatus::Success) {
        auto readIter = &outDataBuf[0];
        typename std::decay<decltype(field)>::type newField;
        auto readEs = newField.read(readIter, size);
        TS_ASSERT_EQUALS(readEs, comms::ErrorStatus::Success);
        TS_ASSERT_EQUALS(field, newField);
    }
}
