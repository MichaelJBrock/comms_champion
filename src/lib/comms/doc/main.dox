/// @mainpage COMMS Library
/// @tableofcontents
/// @b COMMS is the headers only, platform independent library, 
/// which makes the implementation of a communication
/// protocol to be an easy and relatively quick process. It provides all the necessary
/// types and classes to make the definition of the custom messages, as well as
/// wrapping transport data fields, to be simple declarative statements of type and
/// class definitions. These statements will specify @b WHAT needs to be implemented. 
/// The @b COMMS library internals handle the **HOW** part.
///
/// The internals of the @b COMMS library is mostly template classes which use 
/// multiple meta-programming techniques. As the result, only the functionality,
/// required by the protocol being developed, gets compiled in, providing the best code size and
/// speed performance possible. The down side is that compilation process may
/// take a significant amount of time and consume a lot of memory.
///
/// The @b COMMS library allows having <b>single implementation</b> of the binary 
/// protocol messages, which can be re-compiled and used for any possible application:
/// bare-metal with constrained resources, Linux based embedded systems, even 
/// independent GUI analysis tools.
///
/// The @b COMMS library was specifically developed to be used in **embedded** systems
/// including @b bare-metal ones. It doesn't use exceptions and/or RTTI. It also
/// minimises usage of dynamic memory allocation and provides an ability to exclude
/// it altogether if required, which may be needed when developing @b bare-metal
/// embedded systems. 
/// 
/// Below is a quick tutorial on how to use the library.
/// 
/// @section mainpage_comms_header Headers and Libraries
/// COMMS is a headers only library without any object files to link against. 
/// In order to include the whole functionality of the library please use
/// single include statement:
/// @code
/// #include "comms/comms.h"
/// @endcode
///
/// @section mainpage_error_handling Error Handling
/// The COMMS library is intended to be used in embedded systems (including 
/// bare metal), which means the library cannot use exceptions to report errors.
/// The runtime errors are reported via comms::ErrorStatus return values. All
/// pre- and post-conditions are checked using GASSERT() macro.
/// It is, just like regular standard @b assert() macro, is compiled in if @b NDEBUG symbol
/// is not defined. In case the provided condition doesn't hold true, the macro
/// checks whether custom assertion failure behaviour was registered. If yes,
/// the registered custom assertion failure report is invoked, otherwise the
/// standard failure report used by standard @b assert() macro is used. If COMMS
/// library is used in bare metal environment without standard library, the
/// @b NOSTDLIB symbol should be defined. In this case infinite loop is a default
/// assertion failure report behaviour.
///
/// See @ref page_assert for details on how to define custom assertion failure
/// behaviour.  
///
/// @section mainpage_messages Messages
/// The communication protocols are all about exchanging messages. 
/// Please refer to @ref page_message_tutorial for full information on how to
/// create message classes and common polymorphic interfaces for them.
///
/// @section mainpage_transport_info Transport Info
/// Every message needs to be wrapped in some kind of transport information to
/// insure its safe and correct delivery over I/O link. Let's assume our 
/// custom protocol wraps the serialised messages in the following way:
/// @code
/// SYNC | SIZE | ID | PAYLOAD | CHECKSUM 
/// @endcode    
/// where:
/// @li SYNC - 2 bytes of synchronisation value to indicate beginning of the message, 
///     must be "0xab 0xbc"
/// @li SIZE - 2 bytes, length of remaining data including checksum and not 
///     including SIZE field itself.
/// @li ID - 1 byte, numeric ID of the message.
/// @li PAYLOAD - any number of bytes, serialised message data
/// @li CHECKSUM - 2 bytes, CRC-CCITT value of all bytes starting (and
///     including) from SIZE field and ending after PAYLOAD field.
///
/// To be consistent with previous examples, let's require all the transport 
/// data fields to be serialised using big endian.
///
/// The COMMS library calls transport information "protocol stack" when every
/// field (SYNC, SIZE, ID, PAYLOAD, CHECKSUM) is handled by it's own "layer".
/// The definition of all the layers defined by the COMMS library reside in
/// comms::protocol namespace.
///
/// During read/write operation every layer has to handle the  
/// piece of information, it is responsible for, @b before or @b after performing
/// the same read/write operation on the next layer. The COMMS library implements
/// such functionality by wrapping one layer by the other. The implementation
/// of the example above will look like this:
/// @diafile protocol_stack.dia
///
/// The @b SYNC layer is outermost one. It reads first 2 bytes of available data.
/// If they have the expected value of "0xabcd", then it calls the @b read()
/// member function of the next layer.
/// 
/// Although next information in the raw bytes sequence is the length of the
/// remaining data, the next layer is @b CHECKSUM. This is because it needs to 
/// calculate and verify checksum on all the bytes between @b SIZE and @b PAYLOAD information. 
/// First, the @b CHECKSUM layer records the current location of the data in the
/// input buffer (stores the value of the iterator used for reading). Then it 
/// calls the @b read() member function of the next layer (which is @b SIZE).
/// If the latter reports successful processing of the data when it returns, 
/// the checksum on the processed bytes (between the recorded start of the @b SIZE
/// information and the current location of the still unprocessed data in the 
/// input buffer) is calculated by the @b CHECKSUM layer. After calculation is 
/// complete, the next 2 bytes of the expected checksum is read. If the "calculated"
/// and "expected" values match, then success is reported as the result of the
/// @b CHECKSUM layer read operation.
///  
/// The next layer is responsible to process @b SIZE information. It reads the
/// remaining length value and checks whether there are enough remaining bytes
/// in the input buffer to process rest of the fields.
///
/// The next layer is responsible to process @b ID information. When the @b ID value
/// is read, it uses its internal logic to create and default construct 
/// proper custom message object (based on @b ID information). Once the proper
/// message object is created, the next layer's @b read() member function is called.
///
/// The last layer is responsible to handle the message data (@b PAYLOAD). It
/// just invokes @b read() member function of the message object created in the
/// upper layer (@b ID).
///
/// The write operation is very similar to read. First the @b SYNC layer writes
/// the sync value (0xabcd) to the output buffer, then invokes the write
/// operation of the @b CHECKSUM. The checksum layer first invokes the write
/// operation of the next layer (@b SIZE), then calculates the checksum on the
/// data written by the inner layers and writes the value to the output buffer.
/// The @b SIZE layer reserves the space (2 bytes) for the size information, then
/// invokes the write operation of the next layer (@b ID). Once it returns, the
/// @b SIZE layer calculates number of bytes written, adds 2 (length of the
/// @b CHECKSUM value that will be appended later) to the calculated result and
/// writes the value in the reserved earlier area. The @b ID layer will write the
/// ID of the message being written and invoke the write operation of the next
/// layer (@b PAYLOAD). The @b PAYLOAD layer will just call @b write() member function
/// of the message object being written, which will write the contents of the
/// message to the output buffer.
///   
/// In order to implement such protocol stack with COMMS library, we need to
/// start with innermost layer (@b PAYLOAD) and then wrap them one-by-one until
/// we reach the outermost one (@b SYNC).
/// 
/// The serialised message data (@b PAYLOAD) is handled by comms::protocol::MsgDataLayer:
/// @code
/// typedef comms::protocol::MsgDataLayer<> MyMsgData;
/// @endcode
///
/// The next layer is responsible to handle message ID, it is handled by
/// comms::protocol::MsgIdLayer.
/// @code
/// typedef comms::field::EnumValue<CommonFieldBase, MsgId> MsgIdField;
/// typedef std::tuple<
///     Message1,
///     Message2,
///     Message3,
///     ...
/// > InputMessages; 
/// typedef comms::protocol::MsgIdLayer<MsgIdField, MyMessage, InputMessages, MyMsgData> MyMsgId;
/// @endcode 
/// The first template parameter is @b MsgIdField, which is type of the field that is responsible to read/write
/// message ID information. @b CommonFieldBase is the base class for all the fields
/// defined in @ref mainpage_messages section above. @b MsgId is an enum type
/// used to specify ID of the message, was also defined in @ref mainpage_messages 
/// section above. Note, that underlying type of @b MsgId is @b std::uint8_t,
/// which causes serialisation length of the @b MsgIdField to be exactly 1 byte.@n
/// @b MyMsgId layer is defined to be comms::protocol::MsgIdLayer
/// that uses @b MsgIdField to read/write the ID information. @n
/// Second template paramter is the interface class for all the @b incoming messages
/// that this layer must recognise (@b MyMessage in the example). 
/// Third template parameter to comms::protocol::MsgIdLayer is @b InputMessages, which is
/// @b std::tuple of all the @b incoming message types that need to be recognised. @n
/// Fourth template parameter is the 
/// @b MyMsgData layer defined earlier, which is responsible to handle the PAYLOAD. @n
/// When new valid sequence of bytes is received over I/O link, the @b MyMsgId
/// layer is responsible to read the ID field information and create proper
/// custom message object (@b Message1, or @b Message2, or @b Message3, ...).
///
/// The next layer is responsible to handle the remaining size information. The
/// COMMS library provides comms::protocol::MsgSizeLayer layer to handle it.
/// @code
/// typedef comms::field::IntValue<
///     CommonFieldBase, 
///     std::uint16_t, 
///     comms::option::NumValueSerOffset<sizeof(std::uint16_t)> 
/// > RemSizeField;
/// typedef comms::protocol::MsgSizeLayer<RemSizeField, MyMsgId> MyMsgSize;
/// @endcode
/// The @b RemSizeField is a definition of the field that is responsible to
/// read/write remaining length of following data. Note, that it uses 
/// comms::option::NumValueSerOffset option to add 2 (@b sizeof(std::uint16_t)) to
/// the value being written. When reading the value, the does the opposite, it
/// subtracts 2 from the read value in order to receive amount of bytes needed
/// to read ID and PAYLOAD information this layer wraps.@n
/// The comms::protocol::MsgSizeLayer receives two template parameters. The first one
/// is the type of the field, that is used to read/write remaining length information, and
/// the second one is the inner layer being wrapped.
/// 
/// The next layer in our example is responsible to handle the checksum
/// calculation and verification. The COMMS library provides comms::protocol::ChecksumLayer
/// for this purpose.
/// @code
/// typedef comms::field::IntValue<CommonFieldBase, std::uint16_t> ChecksumField;
/// typedef comms::protocol::ChecksumLayer<
///     ChecksumField,
///     comms::protocol::checksum::Crc_CCITT
///     MyMsgSize
/// > MyChecksum;
/// @endcode
/// The @b ChecksumField type defines a field that is responsible to read/write
/// the 2 bytes of the checksum value.@n
/// The comms::protocol::ChecksumLayer class receives three template parameters.
/// The first one the the type of the field, that is used to read/write the
/// checksum value. The second one is a type of the checksum calculator, please
/// refer to the documentation of comms::protocol::ChecksumLayer for description
/// of the types/functions it must provide. The COMMS library provides several
/// available calculators which are defined in comms::protocol::checksum namespace.
/// The example above uses comms::protocol::checksum::Crc_CCITT calculator, which calculates standard
/// CRC-CCITT value. The third template parameter to comms::protocol::ChecksumLayer
/// is the inner layer class being wrapped.  
///
/// The last layer in our example protocol is responsible to handle the 
/// handle the synchronisation sequence of bytes. The COMMS library provides
/// comms::protocol::SyncPrefixLayer for this purpose.
/// @code
/// typedef comms::field::IntValue<
///     CommonFieldBase, 
///     std::uint16_t, 
///     comms::option::DefaultNumValue<0xabcd> 
/// > SyncField;
/// typedef comms::protocol::SyncPrefixLayer<SyncField, MyMsgId> MySyncPrefix;
/// @endcode
/// The @b SyncField type defines a field that is responsible to read/write
/// the SYNC value. Please pay attention, that it will store value 0xabcd when
/// default constructed, thanks to comms::option::DefaultNumValue option being
/// used. 
/// The comms::protocol::SyncPrefixLayer layer class receives two template
/// parameters. The first one is the type of the field used to read/write 
/// @b SYNC value. The second one is the inner protocol layer being wrapped.
/// When performing read operation this layer will compare the value read
/// from the input buffer to the value of default constructed @b SyncField.
/// If they are equal, means the SYNC characters are found and read operation
/// can be forwarded to the inner layer. If they are not equal, it means that
/// the input buffer is out of sync, and error will be returned.
///
/// After all these type definitions we've defined a full "Protocol Stack" of
/// transport information for our protocol. It is time to name it properly to avoid
/// confusion:
/// @code
/// typedef MySyncPrefix ProtStack;
/// @endcode 
///
/// @section tutorial_polymorphic_read Polymorphic Read
/// The COMMS library doesn't make any assumptions about what I/O link is used
/// as a communication channel, and doesn't provide any low level socket
/// abstractions. It is a job of the library's client to manage the communication,
/// store accumulated data somewhere and make it available for processing.
///
/// When new data has been read from I/O link it needs to be read and processed.
/// The received message needs to be recognised dispatched to appropriate handling function.
/// The code needs to be the same for all types of messages. It means that 
/// message interface must allow @b polymorphic read. In other words,
/// the message interface needs to define iterator used for reading:
/// @code
/// class MyMessage : public
///     comms::Message<
///         ...
///         comms::option::ReadIterator<const std::uint8_t*>, 
///         ... 
///     >
/// {
///     ...
/// };
/// @endcode
///
/// The data processing logic can be implemented like this:
/// @code
/// ProtStack protStack; // Protocol stack defined in previous section
/// std::size_t processInput(const std::uint8_t* buf, std::size_t len)
/// {
///     std::size_t consumed = 0U;
///     // Processing loop
///     while (consumed < len) {
///         ProtStack::MsgPtr msgPtr; // Smart pointer to the message object.
///
///         typedef ProtStack::MsgPtr::element_type MsgType; // Type of the message interface class
///     
///         auto begIter = comms::readIteratorFor<MsgType>(buf + consumed);
///         auto iter = begIter;
///
///         auto es = protStack.read(msgPtr, iter, len - consumed);
///         if (es == comms::ErrorStatus::NotEnoughData) {
///             break; // Not enough data in the buffer, stop processing
///         } 
///     
///         if (es == comms::ErrorStatus::ProtocolError) {
///             // Something is not right with the data, remove one character and try again
///            ++consumed;
///             continue;
///         }
///
///         if (es == comms::ErrorStatus::Success) {
///             assert(msgPtr); // If read is successful, msgPtr is expected to hold a valid pointer
///             ... // Dispatch message for handling, explained in the next section.
///         }
///
///         // The iterator for reading has been advanced, update the difference
///         consumed += std::distance(begIter, iter);
///     }
///
///     // Report how many bytes have been consumed from the buffer
///     report consumed;
/// }
/// @endcode
/// Please pay attention to the following details:
/// @li The protocol stack type defines defines type of the smart pointer that 
///     holds message object that was allocation during @read operation:
///     @code
///     ProtStack::MsgPtr msgPtr;
///     @endcode
/// @li The @b ProtStack::MsgPtr is a variant of 
///     <a href="http://en.cppreference.com/w/cpp/memory/unique_ptr">unique_ptr</a>.
///     As the result the type of the interface can be retrieved using internal
///     type @b element_type:
///     @code
///     typedef ProtStack::MsgPtr::element_type MsgType;
///     @endcode
/// @li The innermost layer of protocol stack (comms::protocol::MsgDataLayer)
///     will invoke @b polymorphic read interface of the allocated message
///     (see comms::Message::read()). It means that the iterator used the
///     full read needs to be convertible to comms::Message::ReadIterator. It
///     can be achieved by using comms::readIteratorFor() template function, 
///     which will initialise and return appropriate iterator type. Another 
///     possible way of allocating the iterator can be as following:
///     @code
///     MsgType::ReadIterator iter = buf + consumed;
///     @endcode
///
/// See the @ref page_prot_stack_tutorial page for more examples and guidelines
/// on how to define various protocol stacks.
///
/// @section message_handling Polymorphic Dispatching and Handling of the Message
/// Once the raw sequence of bytes is received on I/O link, the message object
/// is created by the @b Protocol @b Stack (see @ref mainpage_transport_info) and held by smart pointer to 
/// @b MyMessage interface. At this moment the proper type of the message is 
/// invisible. The COMMS library provides an easy and efficient way to downcast
/// message object to its appropriate type by using @b polymorphic dispatch call
/// (see comms::Message::dispatch()).
///
/// First of all such call needs to be enabled in the interface by using
/// comms::option::Handler and providing type of the handler as a template
/// parameter:
/// @code
/// class MyMessage : public
///     comms::Message<
///         ...
///         comms::option::Handler<MyHandler>, 
///         ... 
///     >
/// {
///     ...
/// };
/// @endcode
///
/// Second, the actual handler class needs to be defined. It is expected to
/// define @b handle() member function for all types of messages it needs to handle.
/// @code
/// class MyHandler
/// {
/// public:
///     void handle(Message1& msg) {...}
///     void handle(Message2& msg) {...}
///     void handle(Message3& msg) {...}
///
///     // Common handling functions for other types of messages.
///     void handle(MyMessage& msg) {...}
/// }
/// @endcode
/// When providing actual message type using comms::option::MsgType option
/// to comms::MessageBase class, it invokes proper @b handle() member function
/// of the handler class in its comms::MessageBase::dispatchImpl() member
/// function. If appropriate @b handle() member function in the handling class
/// can not be found, the compiler will choose the next best match, which
/// happen to be <b>void handle(MyMessage& msg)</b> one. This function can
/// be used to implement common "don't care" functionality.
/// 
/// To help with the creation of the handler class, the @b COMMS library provides
/// comms::GenericHandler. It has two template parameters. The first one
/// is a type of common interface class (@b MyMessage). The second one is all the messages it
/// should be able to handle bundled in @b std::tuple. As the result 
/// it defines "virtual handle(MyMessage& msg)" function
/// which does nothing, and for every type in the provided tuple of message types
/// defines "virtual handle(MessageType& msg)" function which upcasts the
/// specific type of the message to the interface class @b MyMessage and calls
/// "handle(MyMessage&)" function. For example, the following code
/// @code
/// typedef std::tuple<
///     Message1,
///     Message2,
///     Message3,
///     ...
/// > AllMessages;
///
/// class MyHandler : public comms::GenericHandler<MyMessage, AllMessages>
/// {
/// }
/// @endcode
/// is equivalent to implementing:
/// @code
/// class MyHandler 
/// {
/// public:
///     virtual void handle(Message1& msg) {
///         this->handle(static_cast<MyMessage&>(msg));
///     }
///
///     virtual void handle(Message2& msg) {
///         this->handle(static_cast<MyMessage&>(msg));
///     }
///     ...
///     virtual void handle(MyMessage& msg) {
///         // do nothing
///     }
/// }
/// @endcode
/// By overriding the relevant @b handle() functions in the @b MyHandler class,
/// it is easy to handle only limited number of messages and ignoring all the rest.
/// @code
/// class MyHandler : public comms::GenericHandler<MyMessage, AllMessages>
/// {
/// public:
///     virtual void handle(Message1& msg) override {
///         ... // handle Message1
///     }
///
///     virtual void handle(Message2& msg) override {
///         ... // handle Message2
///     }
///
///     virtual void handle(MyMessage& msg) override {
///         std::cout << "Ignoring message" << std::endl;
///     }
/// }
/// @endcode
/// 
/// Below is the previous example of reading the message from @ref tutorial_polymorphic_read
/// complemented with dispatching created message for handling:
/// @code
/// ProtStack protStack; // Protocol stack defined in previous section
/// MyHandler handler;
/// std::size_t processInput(const std::uint8_t* buf, std::size_t len)
/// {
///     std::size_t consumed = 0U;
///     // Processing loop
///     while (consumed < len) {
///         ... 
///
///         auto es = protStack.read(msgPtr, iter, len - consumed);
///         ...
///
///         if (es == comms::ErrorStatus::Success) {
///             assert(msgPtr); // If read is successful, msgPtr is expected to hold a valid pointer
///             msgPtr->dispatch(handler);
///         }
///
///         ...
///     }
///
///     // Report how many bytes have been consumed from the buffer
///     report consumed;
/// }
/// @endcode
/// Please read @ref page_handler_tutorial for more details and examples.
/// 
/// @section tutorial_polymorphic_write Polymorphic Write
/// The @b COMMS library allows allows implementation of the single writing (serialisation) 
/// function applicable for all the messages. Something like:
/// @code
/// void sendMessage(const MyMessage& msg)
/// {
///     ...
/// }
/// @endcode
///
/// In order to allow such polymorhic write, the message interface must define
/// appropriate interface by providing iterator used for writing, and allowing
/// polymorphic retrieval of ID and serialisation length information
/// @code
/// class MyMessage : public
///     comms::Message<
///         ...
///         comms::option::WriteIterator<std::uint8_t*>, // define polymorphic write
///         comms::option::LengthInfoInterface, // allow polymorphic retrieval of length information
///         comms::option::IdInfoInterface, // allow polymorphic retrieval of message ID information
///         ... 
///     >
/// {
///     ...
/// };
/// @endcode
/// 
/// In order to identify storage size required to write
/// the message with all the transport related fields, use "length()" member
/// function of the protocol stack object:
/// @code
/// ProtStack protStack; // Protocol stack defined in one of previous sections
/// void sendMessage(const MyMessage& msg)
/// {
///     std::vector<std::uint8_t> dataToSend; // Data to be sent via I/O link
///
///     auto reqLen = protStack.length(msg); // Number of bytes required to serialise the message;
///     dataToSend.resize(reqLen);
///     auto writeIter = comms::writeIteratorFor<MyMessage>(&dataToSend[0]);
///     auto es = protStack.write(msg, writeIter, dataToSend.size());
///     if (es == comms::ErrorStatus::Success) {
///         ... // Send contents of dataToSend via I/O link
///     }
/// }
/// @endcode
/// Similar to comms::readIteratorFor(), explained in @ref tutorial_polymorphic_read
/// section, the comms::writeIteratorFor() function may be used to initialise and
/// obtain iterator used for writing.
///
/// As another example let's go back and redefine the @b MyMessage interface
/// class to use <a href="http://en.cppreference.com/w/cpp/iterator/back_insert_iterator">std::back_insert_iterator</a>  
/// for std::vector<std::uint8_t> to be able to write to the vector without 
/// initial creation of the storage space:
/// @code
/// class MyMessage : public
///     comms::Message<
///         ...
///         comms::option::WriteIterator<std::back_insert_iterator<std::uint8_t> >, 
///     >
/// {
///     ...
/// };
/// @endcode
/// In this case the write functionality may be changed into following:
/// @code
/// ProtStack protStack; // Protocol stack defined in one of previous sections
/// void sendMessage(const MyMessage& msg)
/// {
///     std::vector<std::uint8_t> dataToSend; // Data to be sent via I/O link
///
///     auto writeIter = std::back_inserter(dataToSend);
///     auto es = protStack.write(msg, writeIter, dataToSend.max_size());
///     if (es == comms::ErrorStatus::UpdateRequired) {
///         // The checksum could not be calculated right away, 
///         // create random-access iterator and update the written value
///         auto* updateIter = &dataToSend[0];
///         es = proptStack.update(updateIter, dataToSend.size());
///     }
///
///     if (es == comms::ErrorStatus::Success) {
///         ... // Send contents of dataToSend via I/O link
///     }
/// }
/// @endcode
///
/// @section tutorial_write Direct (NON-Polymorphic) Write
/// Sometimes it may be useful to write a common @b non polymorphic code to write
/// a message.
/// @code
/// ProtStack protStack; // Protocol stack defined in one of previous sections
///
/// template <typename TMsg>
/// void sendMessage(const TMsg& msg)
/// {
///     std::vector<std::uint8_t> dataToSend; // Data to be sent via I/O link
///
///     auto writeIter = std::back_inserter(dataToSend);
///     auto es = protStack.write(msg, writeIter, dataToSend.max_size());
///     ...
/// }
/// 
/// Message1 msg1;
/// sendMessage(msg1);
///
/// Message2 msg2;
/// sendMessage(msg2);
/// @endcode
/// In this case the @b COMMS library knows what messages are being written and
/// can invoke @b doWrite non-virtual function (see comms::MessageBase::doWrite())
/// defined by the message itself when serialising message. It eliminates a 
/// necessity of having polymorphic interface with various necessary functions
/// and and can significantly reduce the size of virtual tables
/// of the messages. 
///
